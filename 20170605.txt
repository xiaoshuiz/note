1.	开发者选项中的GPU过度绘制工具来进行分析。
	无色	WebView等的渲染区域
	蓝色	1x过度绘制
	绿色	2x过度绘制
	淡红色	3x过度绘制
	红色	4x(+)过度绘制
	所以最理想的就是绘制一次，也就是蓝色（当然这在很多绚丽的界面是不现实的，所以大家有个度即可，我们的开发性		能优化标	准要求最极端界面下红色区域不能长期持续超过屏幕三分之一，可见还是比较宽松的规定），因此我们需要依	据此颜色分布进行代码优化，譬如：
	1.优化布局层级、
	2.减少没必要的背景、
	3.暂时不显示的View设置为GONE而不是NVISIBLE	
	4.自定义View的onDraw方法设置canvas.clipRect()
	5.指定绘制区域或通过canvas.quickreject()减少绘制区域等。

2.	GPU呈现模式分析
	打开上图可视化工具后，我们可以在手机画面上看到丰富的GPU绘制图形信息，分别展示了StatusBar、NavgationBar	、Activity区域等的GPU渲染时间信息，随着界面的刷新，界面上会以实时柱状图来显示每帧的渲染时间，柱状图越高	表示渲染时间越长，每个柱状图偏上都有一根代表16ms基准的绿色横线，每一条竖着的柱状线都包含三部分（蓝色代表	测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间	），只要我们每一帧的总时间低于基准线就不会发生UI卡顿问题（个别超出基准线其实也不算啥问题的）
	

3.	使用Lint进行资源及冗余UI布局等优化
	点击右键->Analyze->Inspect CodeC>界面选择你要检测的模块->点击确认开始检测

4.	避免大面积打印GC导致所有线程暂停的造作的常见优化方式：
	1.检查代码，尽量避免有些频繁触发的逻辑方法中存在大量对象分配；
	2.尽量避免在多次for循环中频繁分配对象；
	3.避免在自定义View的onDraw()方法中执行复杂的操作及创建对象（譬如Paint的实例化操作不要写在onDraw()方法	中等）；
	4.对于并发下载等类似逻辑的实现尽量避免多次创建线程对象，而是交给线程池处理。

5.	Allocation Tracker
	tools->android device monitor->DDMS->Allocation Tracker可以查看代码分配了哪类对象，在哪个线程，哪个	类，那个文件的哪一行。譬如我们可以通过Allocation Tracker分别做一次Paint对象实例化在onDraw与构造方法的	一个自定义View的内存跟踪，然后你就明白这个工具的强大了。

6.	Traceview
	他是一个分析器，记录了应用程序中每个函数的执行时间；我们可以打开DDMS然后选择一个进程，接着点击上面		的“Start Method Profiling”按钮（红色小点变为黑色即开始运行），然后操作我们的卡顿UI（小范围测试，所以	操作最好不要超过5s）
	一般Traceview可以定位两类性能问题：
	方法调运一次需要耗费很长时间导致卡顿；
	方法调运一次耗时不长，但被频繁调运导致累计时长卡顿。
	譬如我们来举个实例，有时候我们写完App在使用时不觉得有啥大的影响，但是当我们启动完App后静止在那却十分费电	或者导致设备发热，这种情况我们就可以打开Traceview然后按照Cpu Time/Call或者Real Time/Call进行降序排列	，然后打开可疑的方法及其child进行分析查看，然后再回到代码定位检查逻辑优化即可；当然了，我们也可以通过该	工具来trace我们自定义View的一些方法来权衡性能问题，这里不再一一列举喽。

7.	Traceview家族还有一个更加直观强大的小工具，那就是可以通过dmtracedump生成方法调用图。
	命令行模式下 dmtracedump -g result.png target.trace  //结果png文件  目标trace文件
	通过这个生成的方法调运图我们可以更加直观的发现一些方法的调运异常现象。不过本人优化到现在还没怎么用到它，	每次用到Traceview分析就已经搞定问题了，所以说dmtracedump自己酌情使用吧。

8.	使用Systrace进行分析优化
	DDMS->Capture system wide trace using Android systrace->设置时间与选项点击OK就开始了抓取，接着操作	APP，完事生成一个trace.html文件，用Chrome打开

9.	我们应用开发中常见的ANR主要有如下几类：
	按键触摸事件派发超时ANR，一般阈值为5s（设置中开启ANR弹窗，默认有事件派发才会触发弹框ANR）；
	广播阻塞ANR，一般阈值为10s（设置中开启ANR弹窗，默认不弹框，只有log提示）；
	服务超时ANR，一般阈值为20s（设置中开启ANR弹窗，默认不弹框，只有log提示）；

10.	使用traces.txt文件进行ANR分析优化
	当ANR发生时除过logcat可以看见的log以外我们还可以在系统指定目录下找到traces文件或dropbox文件进行分析，	发生ANR后我们可以通过如下命令得到ANR trace文件：
	adb pull /data/anr/traces.txt ./然后我们用txt编辑器打开

11.	写一个标题的布局 title.xml 然后在其它几个类似的页面<include> 上面的title.xml 即可
	如果想在 <include ...> 标签中使用 layout_** 属性，那么必须得在include 中包含 android:layout_height 		和 android:layout_width，否则其它layout_** 属性 不会生效

12.	使用Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的	控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为	可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub	的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。

13.	ViewStub的一些特点：
	1. ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后	，就不会够再通过ViewStub来控制它了。
        2. ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。

14.	可以考虑使用ViewStub的情况有：
        1. 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。
        	因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当		需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来		控制了。
        2. 想要控制显示与隐藏的是一个布局文件，而非某个View。
		因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。
		所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某			个布局或View，只能使用View的可见性来控制。

15.	某些布局属性要加在ViewStub而不是实际的布局上面，才会起作用，比如上面用的android:layout_margin*系列属性	，如果加在TextView上面，则不会起作用，需要放在它的ViewStub上面才会起作用。而ViewStub的属性在inflate()	后会都传给相应的布局。

16.	如果是merge标签，那么直接将其中的子元素添加到merge标签parent中，这样就保证了不会引入额外的层级。

17.	项目代码架构搭建及编写时就应该避免一些UI性能问题，具体项目常见的注意事项如下：
	1.布局优化；尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局（譬如10层就会直接异	常），尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的	嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。
	2.列表及Adapter优化；尽量复用getView方法中的相关View，不重复获取实例导致卡顿，列表尽量在滑动过程中不进		行UI元素刷新等。
	3.背景和图片等内存分配优化；尽量减少不必要的背景设置，图片尽量压缩处理显示，尽量避免频繁内存抖动等问题出		现
	4.自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法		中，尽量减少draw、measure、layout等执行次数。
	5.避免ANR，不要在UI线程中做耗时操作，遵守ANR规避守则，譬如多次数据库操作等。
	
18.	每个虚拟机必定会有堆内存阈值限制（值得一提的是这个阈值一般都由厂商依据硬件配置及设备特性自己设定，没有统	一标准，可以为64M，也可以为128M等；它的配置是在Android的属性系统的/system/build.prop中配置	dalvik.vm.heapsize=128m即可，若存在dalvik.vm.heapstartsize则表示初始申请大小），也即一个应用进程同时	存在的对象必须小于阈值规定的内存大小才可以正常运行。

19.	内存泄露可以引发很多的问题，常见的内存泄露导致问题如下：
	应用卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）;
	应用被从后台进程干为空进程（上面系统内存原理有介绍，也就是超过了阈值）；
	应用莫名的崩溃（上面应用内存原理有介绍，也就是超过了阈值OOM）；

20.	Android应用内存泄露察觉手段
	1.AS的memory窗口
	2.DDMS-Heap内存检测工具 （这两种基本要靠直观了解，大的泄露才能有感知）
	3.dumpsys meminfo 指令  -$ adb shell dumpsys meminfo -a ***（常用方式，不全面 但常规足够用）
	4.leakcanary神器 （比较强大）是著名的github开源组织square贡献的，虽然还存在一些bug，但正常使用大多数情	况是OK的，核心和MAT工具类似。
	5.MAT（memory Analysis Tools）工具定位分析  		http://blog.csdn.net/zxm317122667/article/details/52162764

21.	内存溢出的主要导致原因有如下几类：
	应用代码存在内存泄露，长时间积累无法释放导致OOM；
	应用的某些逻辑操作疯狂的消耗掉大量内存（譬如加载一张不经过处理的超大超高清图片等）导致超过阈值OOM；

22.	一 内存泄露导致的OOM分析：
	这种OOM一旦发生后会在logcat中打印相关OutOfMemoryError的异常栈信息，不过你别高兴太早，这种情况下导致的			OOM打印异常信息是没有太大作用，这种OOM我们有时也遇到，第一反应是去分析OOM异常打印栈，可是后来发现打印栈			打印的地方没有啥问题，没有可优化的余地了，于是就郁闷了。其实这时候你留心观察几个现象即可，如下：
	1.留意你执行触发OOM操作前的界面是否有卡顿或者比较密集的GC打印；
	2.使用命令查看下当前应用占用内存情况；
	确认了以上这些现象你基本可以断定该OOM的log真的没用，真正导致问题的原因是内存泄露，所以我们应该按照上节介		绍的方式去着手排查内存泄露问题。

	二 不珍惜内存导致的OOM分析：
	这种类型的OOM就很好定位原因了，一般都可以从OOM后的log中得出分析定位。通过log可以很方便的看出来问题原因	所在地，那接下来的做法就是优化呗，降低图片的相关规格即可（譬如使用BitmapFactory的Option类操作等）。
	PS：提醒一句的是记得应用所属的内存是区分Java堆和native堆的！

23.	为什么引进非Java堆？

	Java如果和外界通讯，把Java 堆中的内容传输到外界，则需要把Java堆复制到非Java堆，如果使用native堆，则避免		了内容在Java堆和非Java堆之间的copy.

24.	在什么场景下使用非Java堆？

	非Java堆的回收不收Java yong gc的影响，一般需要手工进行回收。如果大量的使用非Java堆，则丢失了Java 自动		垃圾回收的特点。
	一般使用非Java堆进行和外界通讯，并且做为缓存使用。如DirectByteBuffer。

25.	Android应用规避常见内存溢出OOM建议
	1.时刻记得不要加载过大的Bitmap对象；譬如对于类似图片加载我们要通过BitmapFactory.Options设置图片的一些		采样比率和复用等，具体做法点我参考官方文档，不过过我们一般都用fresco或Glide开源库进行加载。(见26)
	2.优化界面交互过程中频繁的内存使用；譬如在列表等操作中只加载可见区域的Bitmap、滑动时不加载、停止滑动后再	开始加载。
	3.有些地方避免使用强引用，替换为弱引用等操作。（见27）
	4.避免各种内存泄露的存在导致OOM。
	5.对批量加载等操作进行缓存设计，譬如列表图片显示，Adapter的convertView缓存等。
	6.尽可能的复用资源；譬如系统本身有很多字符串、颜色、图片、动画、样式以及简单布局等资源可供我们直接使用，	我们自己也要尽量复用style等资源达到节约内存。
	7.对于有缓存等存在的应用尽量实现onLowMemory()和onTrimMemory()方法。
	8.尽量使用线程池替代多线程操作，这样可以节约内存及CPU占用率。
	9.尽量管理好自己的Service、Thread等后台的生命周期，不要浪费内存占用。
	10.尽可能的不要使用依赖注入，中看不中用。
	11.尽量在做一些大内存分配等可疑内存操作时进行try catch操作，避免不必要的应用闪退。
	12.尽量的优化自己的代码，减少冗余，进行编译打包等优化对齐处理，避免类加载时浪费内存。

26.	图片加载开源库：
	1.Universal Image Loader (一个强大的图片加载库，包含各种各样的配置，最老牌，使用也最广泛。)
	2.Picasso (Square出品，必属精品。和OkHttp搭配起来更配呦)
	3.Volley ImageLoader (Google官方出品，可惜不能加载本地图片~)
	4.Fresco (Facebook出的，天生骄傲！不是一般的强大。)
	5.Glide (Google推荐的图片加载库，专注于流畅的滚动。缓存策略和加载GIF方面略胜一筹)

27.	1.强引用（StrongReference）
	强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁	愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
	2.软引用（SoftReference）
	如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的	内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例	）。
	软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机	就会把这个软引用加入到与之关联的引用队列中。
	3.弱引用（WeakReference）
	弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域	的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器	是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
	弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把	这个弱引用加入到与之关联的引用队列中。
	4.虚引用（PhantomReference）
	“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持	有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
	虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 	（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存	之前，把这个虚引用加入到与之 关联的引用队列中。
